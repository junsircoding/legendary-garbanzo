TCP 和 UDP
==============================

TCP
^^^^^^^^^^^^^^

TCP 和 UDP 都工作在 **传输层** ，TCP 基于 **连接** ，UDP 基于 **非连接** 。

把 UDP 比作写信，我们有很多事情无法确认。

1. 收信地址是否存在
2. 收信人是否收到信
3. 收到的信是否完整
4. 收到的信是否顺序正确


把 TCP 比作打电话，上面这几个问题都能得到即时的反馈。

TCP 能做到这样，有三个特性， **三次握手** 、 **传输确认** 、 **四次挥手** 。

三次握手
-----------------

三次握手是建立连接的过程。

 | 客户端 ----- **SYN** ----> 服务端
 | 客户端 <-- **SYN+ACK** --- 服务端
 | 客户端 ----- **ACK** ----> 服务端

之所以要三次握手，就是要在不可靠的信道上建立可靠的连接。

传输确认
-----------------------

因为信道是不可靠的，所以会有 **丢包问题** 和 **乱序问题** ，传输确认环节也有一系列规则。

TCP 协议为每一个连接建立了一个发送缓冲区，从建立连接都的第一个字节的序列号为 0 ，后面每一个字节的序列号就会增加 1。发送数据时，取一部分数据组成发送报文，在其 TCP 协议头中会附带序列号和长度，接收端在收到报文后需要回复确认报文。确认报文中的 ACK 等于 **接收序列号+长度** ，也就是下一包数据需要发送的起始序列号。

这样一问一答的方式，能够使发送端确认，发送的数据已经被对方收到。

发送端也可以一次性发送连续的多包数据，接收端只需要回复一次 ACK 就可以了。这样发送端可以把要发送的数据分割成一系列的碎片发送到对端。对端根据序列号和长度，在接收后重构出来完整的数据。

假设其中丢失了某些数据包，在接收端可以要求发送端重传，缺失的包信息是包含在 ACK 里面的，发送端收到这个信息后就可以把缺失的包再传一次。

以上过程不区分客户端和服务端， TCP 是全双工的，两端都是这个机制。

四次挥手
--------------------

现在数据传完了，要断开连接了，这就要进行 **四次挥手** 了。

处于连接状态的服务端和客户端都可以发起断开连接请求，假设由客户端发起。

 | 客户端 --- **FIN** --> 服务端
 | 客户端 <-- **ACK** --- 服务端
 | 客户端 <-- **FIN** --- 服务端
 | 客户端 --- **ACK** --- 服务端

客户端经过超时等待后，连接断开。

UDP
^^^^^^^^^^^^^^^

UDP 要简单的多，它只是把数据封装一下就发出去了，因此相比起 TCP 来说性能损耗很小，对于 CPU 的内存资源占用也远小于 TCP 。但是因为信道不可靠，所以会丢包，不稳定。


小结
^^^^^^^^^^^^^^^

TCP 特点是稳定可靠，适用于对传输质量要求较高的场景，如传输文件，发送邮件，浏览网页。

UDP 特点是速度快，适用于实时性要求较高，稳定性要求不高的场景，比如域名查询，语音通话，视频直播等。

UDP 常用的一个场景是隧道网络，比如 VPN，在 SDN 中用到的 VXLAN 。
